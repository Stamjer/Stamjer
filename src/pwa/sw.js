/* eslint-disable no-restricted-globals */
/**
 * Service Worker for Stamjer Application
 * Powered by Workbox via vite-plugin-pwa.
 * Handles precaching, offline navigation, API caching and optional background sync.
 */

import { clientsClaim } from 'workbox-core'
import { precacheAndRoute, cleanupOutdatedCaches, createHandlerBoundToURL } from 'workbox-precaching'
import { registerRoute, NavigationRoute } from 'workbox-routing'
import { CacheFirst, NetworkFirst, StaleWhileRevalidate, NetworkOnly } from 'workbox-strategies'
import { CacheableResponsePlugin } from 'workbox-cacheable-response'
import { ExpirationPlugin } from 'workbox-expiration'

const CACHE_PREFIX = 'stamjer'
const CACHE_VERSION = 'v2'
const API_CACHE_NAME = `${CACHE_PREFIX}-api-${CACHE_VERSION}`
const STATIC_CACHE_NAME = `${CACHE_PREFIX}-static-${CACHE_VERSION}`
const IMAGE_CACHE_NAME = `${CACHE_PREFIX}-images-${CACHE_VERSION}`
const DEFAULT_NOTIFICATION_TITLE = 'Stamjer'
const DEFAULT_NOTIFICATION_BODY = 'Nieuwe update beschikbaar'
const DEFAULT_NOTIFICATION_URL = '/kalender'
const DEFAULT_NOTIFICATION_ICON = '/icons/192x192.png'
const DEFAULT_NOTIFICATION_BADGE = '/stam_H.png'

// Ensure new service worker activates immediately.
self.skipWaiting()
clientsClaim()

async function clearAllCaches() {
  const keys = await caches.keys()
  const deletions = keys
    .filter((key) => key.startsWith(`${CACHE_PREFIX}-`))
    .map((key) => caches.delete(key))
  await Promise.allSettled(deletions)
}

// Precache all assets generated by the build and cleanup stale ones.
cleanupOutdatedCaches()
// eslint-disable-next-line no-underscore-dangle
precacheAndRoute(self.__WB_MANIFEST, {
  ignoreURLParametersMatching: [/^utm_/, /^fbclid$/]
})

// Offline navigation fallback
const offlineFallback = createHandlerBoundToURL('/index.html')
const navigationHandler = new NetworkFirst({
  cacheName: `${CACHE_PREFIX}-pages-${CACHE_VERSION}`,
  networkTimeoutSeconds: 8,
  plugins: [
    new CacheableResponsePlugin({ statuses: [200] }),
    new ExpirationPlugin({
      maxEntries: 20,
      purgeOnQuotaError: true
    })
  ]
})

registerRoute(
  new NavigationRoute(async (params) => {
    try {
      const response = await navigationHandler.handle(params)
      if (!response) {
        throw new Error('Navigation handler returned undefined response')
      }
      return response
    } catch (error) {
      console.warn('[SW] Falling back to offline shell due to', error)
      return offlineFallback(params)
    }
  })
)

// API requests should always hit the network so the database remains source of truth.
registerRoute(
  ({ url, request }) =>
    request.method === 'GET' && (/^\/api\//.test(url.pathname) || /^\/data\//.test(url.pathname)),
  new NetworkOnly(),
  'GET'
)

// Static assets (JS, CSS, workers)
registerRoute(
  ({ request }) => ['style', 'script', 'worker'].includes(request.destination),
  new StaleWhileRevalidate({
    cacheName: STATIC_CACHE_NAME,
    plugins: [new CacheableResponsePlugin({ statuses: [200] })]
  })
)

// Images
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: IMAGE_CACHE_NAME,
    plugins: [
      new CacheableResponsePlugin({ statuses: [200] }),
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 7 * 24 * 60 * 60,
        purgeOnQuotaError: true
      })
    ]
  })
)

// Background sync placeholder for queued form submissions.
self.addEventListener('sync', (event) => {
  if (event.tag === 'background-sync-form') {
    event.waitUntil(processQueuedFormSubmissions())
  }
})

// Push notifications handling
self.addEventListener('push', (event) => {
  event.waitUntil((async () => {
    let payload = {}

    if (event.data) {
      try {
        payload = event.data.json()
      } catch (error) {
        console.warn('[SW] Push payload not JSON, falling back to text', error)
        payload = { body: event.data.text() }
      }
    }

    const notificationData = {
      ...(payload.data || {}),
      url: payload.data?.url || payload.url || DEFAULT_NOTIFICATION_URL,
      type: payload.data?.type || payload.type || 'general',
      notificationId: payload.data?.notificationId || payload.notificationId || null,
      eventId: payload.data?.eventId || payload.eventId || null,
      metadata: payload.data?.metadata || payload.metadata || {}
    }

    const title = payload.title || DEFAULT_NOTIFICATION_TITLE
    const options = {
      body: payload.body || DEFAULT_NOTIFICATION_BODY,
      icon: payload.icon || DEFAULT_NOTIFICATION_ICON,
      badge: payload.badge || DEFAULT_NOTIFICATION_BADGE,
      data: notificationData,
      tag: payload.tag,
      renotify: payload.renotify ?? false,
      requireInteraction: payload.requireInteraction ?? false,
      actions: Array.isArray(payload.actions) && payload.actions.length > 0
        ? payload.actions
        : [
            {
              action: 'open',
              title: 'Openen',
              icon: payload.icon || DEFAULT_NOTIFICATION_ICON
            }
          ]
    }

    await self.registration.showNotification(title, options)
    await broadcastMessage({ type: 'notification-received', payload: options.data })
  })())
})

self.addEventListener('notificationclick', (event) => {
  event.notification.close()

  if (event.action && event.action !== 'open') {
    return
  }

  const targetUrl = event.notification.data?.url || DEFAULT_NOTIFICATION_URL

  event.waitUntil((async () => {
    await openClientWindow(targetUrl, event.notification.data)
    await broadcastMessage({ type: 'notification-clicked', payload: event.notification.data })
  })())
})

async function openClientWindow(url, payload = {}) {
  try {
    const resolvedUrl = new URL(url, self.location.origin).href
    const clientList = await self.clients.matchAll({ type: 'window', includeUncontrolled: true })

    for (const client of clientList) {
      if (!client?.url) continue
      if (client.url === resolvedUrl || client.url === resolvedUrl.replace(self.location.origin, '')) {
        if ('focus' in client) {
          await client.focus()
        }
        client.postMessage({ type: 'notification-clicked', payload })
        return client
      }
    }

    const newClient = await self.clients.openWindow(resolvedUrl)
    if (newClient) {
      newClient.postMessage({ type: 'notification-clicked', payload })
    }
    return newClient
  } catch (error) {
    console.error('[SW] Failed to open client window for notification', error)
    return null
  }
}

async function broadcastMessage(message) {
  try {
    const clientList = await self.clients.matchAll({ type: 'window', includeUncontrolled: true })
    clientList.forEach((client) => {
      try {
        client.postMessage(message)
      } catch (error) {
        console.warn('[SW] Failed to post message to client', error)
      }
    })
  } catch (error) {
    console.warn('[SW] Failed to broadcast message to clients', error)
  }
}

self.addEventListener('message', (event) => {
  if (event?.data?.type === 'CLEAR_CACHES') {
    event.waitUntil(clearAllCaches())
  }
})

async function processQueuedFormSubmissions() {
  try {
    const pendingItems = await readPendingFormItems()
    if (pendingItems.length === 0) {
      return
    }

    for (const item of pendingItems) {
      try {
        await fetch(item.url, {
          method: item.method,
          headers: item.headers,
          body: item.body
        })
        await removePendingFormItem(item.id)
      } catch (error) {
        console.error('[SW] Failed to submit queued form item', error)
      }
    }
  } catch (error) {
    console.error('[SW] Background sync error', error)
  }
}

// Placeholder implementations â€“ integrate with IndexedDB as needed.
async function readPendingFormItems() {
  return []
}

async function removePendingFormItem() {
  return Promise.resolve()
}

console.info('[SW] Service worker loaded')
