/* eslint-disable no-restricted-globals */
/**
 * Service Worker for Stamjer Application
 * Powered by Workbox via vite-plugin-pwa.
 * Handles precaching, offline navigation, API caching and optional background sync.
 */

import { clientsClaim } from 'workbox-core'
import { precacheAndRoute, cleanupOutdatedCaches, createHandlerBoundToURL } from 'workbox-precaching'
import { registerRoute, NavigationRoute } from 'workbox-routing'
import { CacheFirst, NetworkFirst, StaleWhileRevalidate } from 'workbox-strategies'
import { CacheableResponsePlugin } from 'workbox-cacheable-response'
import { ExpirationPlugin } from 'workbox-expiration'

const CACHE_PREFIX = 'stamjer'
const CACHE_VERSION = 'v1'
const API_CACHE_NAME = `${CACHE_PREFIX}-api-${CACHE_VERSION}`
const STATIC_CACHE_NAME = `${CACHE_PREFIX}-static-${CACHE_VERSION}`
const IMAGE_CACHE_NAME = `${CACHE_PREFIX}-images-${CACHE_VERSION}`

// Ensure new service worker activates immediately.
self.skipWaiting()
clientsClaim()

// Precache all assets generated by the build and cleanup stale ones.
cleanupOutdatedCaches()
// eslint-disable-next-line no-underscore-dangle
precacheAndRoute(self.__WB_MANIFEST, {
  ignoreURLParametersMatching: [/^utm_/, /^fbclid$/]
})

// Offline navigation fallback
const offlineFallback = createHandlerBoundToURL('/index.html')
const navigationHandler = new NetworkFirst({
  cacheName: `${CACHE_PREFIX}-pages-${CACHE_VERSION}`,
  networkTimeoutSeconds: 8,
  plugins: [
    new CacheableResponsePlugin({ statuses: [200] }),
    new ExpirationPlugin({
      maxEntries: 20,
      purgeOnQuotaError: true
    })
  ]
})

registerRoute(
  new NavigationRoute(async (params) => {
    try {
      const response = await navigationHandler.handle(params)
      if (!response) {
        throw new Error('Navigation handler returned undefined response')
      }
      return response
    } catch (error) {
      console.warn('[SW] Falling back to offline shell due to', error)
      return offlineFallback(params)
    }
  })
)

// API caching for GET requests to /api and /data
registerRoute(
  ({ url, request }) =>
    request.method === 'GET' && (/^\/api\//.test(url.pathname) || /^\/data\//.test(url.pathname)),
  new NetworkFirst({
    cacheName: API_CACHE_NAME,
    networkTimeoutSeconds: 6,
    plugins: [
      new CacheableResponsePlugin({ statuses: [0, 200] }),
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 5 * 60,
        purgeOnQuotaError: true
      })
    ]
  }),
  'GET'
)

// Static assets (JS, CSS, workers)
registerRoute(
  ({ request }) => ['style', 'script', 'worker'].includes(request.destination),
  new StaleWhileRevalidate({
    cacheName: STATIC_CACHE_NAME,
    plugins: [new CacheableResponsePlugin({ statuses: [200] })]
  })
)

// Images
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: IMAGE_CACHE_NAME,
    plugins: [
      new CacheableResponsePlugin({ statuses: [200] }),
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 7 * 24 * 60 * 60,
        purgeOnQuotaError: true
      })
    ]
  })
)

// Background sync placeholder for queued form submissions.
self.addEventListener('sync', (event) => {
  if (event.tag === 'background-sync-form') {
    event.waitUntil(processQueuedFormSubmissions())
  }
})

// Push notifications (for future enablement).
self.addEventListener('push', (event) => {
  let payload = {}

  if (event.data) {
    try {
      payload = event.data.json()
    } catch (error) {
      payload = { body: event.data.text() }
      console.warn('[SW] Push payload not JSON, falling back to text', error)
    }
  }

  const options = {
    body: payload.body || 'Nieuwe update beschikbaar',
    icon: '/stam_H.png',
    badge: '/stam_H.png',
    data: { url: payload.url || '/' },
    actions: [
      {
        action: 'open',
        title: 'Openen',
        icon: '/stam_H.png'
      }
    ]
  }

  event.waitUntil(self.registration.showNotification('Stamjer', options))
})

self.addEventListener('notificationclick', (event) => {
  event.notification.close()
  if (event.action === 'open' || !event.action) {
    event.waitUntil(self.clients.openWindow(event.notification.data?.url || '/'))
  }
})

async function processQueuedFormSubmissions() {
  try {
    const pendingItems = await readPendingFormItems()
    if (pendingItems.length === 0) {
      return
    }

    for (const item of pendingItems) {
      try {
        await fetch(item.url, {
          method: item.method,
          headers: item.headers,
          body: item.body
        })
        await removePendingFormItem(item.id)
      } catch (error) {
        console.error('[SW] Failed to submit queued form item', error)
      }
    }
  } catch (error) {
    console.error('[SW] Background sync error', error)
  }
}

// Placeholder implementations â€“ integrate with IndexedDB as needed.
async function readPendingFormItems() {
  return []
}

async function removePendingFormItem() {
  return Promise.resolve()
}

console.info('[SW] Service worker loaded')
